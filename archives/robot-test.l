#!/usr/bin/env roseus
;; vim: set ft=lisp:
;; -*- mode: lisp;-*-

(ros::roseus "robot_test")

(require "package://jsk_2015_05_baxter_apc/euslisp/utils.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/robot-init.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/robot-utils.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/robot-interface.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/robot-motions.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/robot-communication.l")
(require "package://jsk_2015_05_baxter_apc/euslisp/debug.l")

(defun test-for-bin (arm bin &key (verify nil))
  (ros::ros-info "test for ~A" bin)
  (move-to-target-bin arm bin)
  (pick-object arm bin)
  (place-object arm))

(defun test-challenge (&key
              (bins (list :a :b :c :d :e :f :g :h :i :j :k :l))
              (use-arm (list :larm :rarm))
              (tweet? t)
              (verify? nil))
  (ros::advertise-if-yet "tweet" std_msgs::string 1)
  (let ((start-time (ros::time-now))
        elapsed-time elapsed-msg arm msg)
    (dolist (bin bins)
      (if (eq (length use-arm) 1) (setq arm (elt use-arm 0))  ;; only use arms in use-arm
        (cond
          ((find bin (list :a :d :g :j)) (setq arm :larm))
          ((find bin (list :c :f :i :l)) (setq arm :rarm))
          (t (setq arm :larm))))
      (test-for-bin arm bin :verify verify?))
    (setq elapsed-time (ros::time- (ros::time-now) start-time))
    (setq elapsed-msg (format nil "It takes ~d min ~d sec" (/ (send elapsed-time :sec) 60) (mod (send elapsed-time :sec) 60)))
    (when tweet? (tweet elapsed-msg))  ;; tweet elapsed time
    ;; return to fold pose and speak
    (send *ri* :angle-vector-sequence (send *baxter* :fold-pose-back arm))
    (send *ri* :wait-interpolation)
    (speak-en "Finished picking test." :google t)
    ))

(defun test-return-object (arm bin)
  (do-until-key
    (send *ri* :start-grasp arm)
    (send *ri* :angle-vector (send *baxter* :fold-pose) :fast (arm-to-ctype arm))
    (send *ri* :wait-interpolation)
    (unix::sleep 1)
    (move-to-target-bin arm bin)
    (return-object arm bin)))

(defun test-insert-arm ()
  (let ((bins '(:a :b :c :d :e :f :g :h :i :j :k :l)) arm)
    (dolist (bin bins)
      (case (which-bin-region bin)
        (:center :left (setq arm :larm))
        (:right (setq arm :rarm)))
      (move-to-target-bin arm bin)
      (send *ri* :angle-vector-sequence (insert-to-pick-object-avs arm bin))
      (send *ri* :wait-interpolation)
      (unix::sleep 3)
      (send *ri* :angle-vector (avoid-shelf-pose-for-bin arm bin))
      (send *ri* :wait-interpolation)
      )
    ))

(defun test-pick-object-depth (arm bin)
  ;; insert arm to target bin
  (dolist (av (insert-to-pick-object-avs arm bin))
    (send *irtviewer* :draw-objects)
    (send *ri* :angle-vector av 3000)
    (send *ri* :wait-interpolation))
  (send *ri* :start-grasp arm)
  (dolist (pattern-depth '((:middle . 0) (:middle . 80) (:middle . 150) (:middle . 200)))
    (format t "pattern ~A, depth ~A~%" (car pattern-depth) (cdr pattern-depth))
    (try-to-pick-object arm bin (car pattern-depth) (cdr pattern-depth) :call-check-if-grabbed-function nil))
  (send *ri* :stop-grasp arm)
  )

(defun check-pick ()
  (send *ri* :stop-grasp)
  (dolist (bins '((:a . :c) (:d . :f) (:g . :i) (:j . :l)))
    (format t "move to ~A and ~A~%" (car bins) (cdr bins))
    (when (member (car bins) '(:a :d))
      (send *baxter* :fold-to-keep-object :larm)
      (send *baxter* :fold-to-keep-object :rarm)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
      (send *ri* :wait-interpolation))
    (move-to-target-bin :larm (car bins))
    (move-to-target-bin :rarm (cdr bins))
    (test-pick-object-depth :larm (car bins))
    (test-pick-object-depth :rarm (cdr bins))
    ;; back to bin front
    (move-to-target-bin-av :larm (car bins))
    (move-to-target-bin-av :rarm (cdr bins))
    (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
    (send *ri* :wait-interpolation)
    ))

(defun check-pick-offset-impl (arm bin &key (pattern '((:middle . 30) (:middle . 80) (:middle . 150))))
  (let ((last-z nil)
        (ret-zs nil))
    (dolist (pat pattern)
      (send *ri* :start-grasp arm)
      (catch 'loop
        (dolist (z '(70 75 80 85 90 95 100 105 110 115 120 125 130))
          (insert-to-pick-object-avs arm bin)
          ;;(send *baxter* arm :move-end-rot 2 :y :local :revert-if-fail nil) ;; use same value used in pick-object
          (move-end-rot-with-interpolation arm :y 2 :time 1000)
          (move-end-pos-with-interpolation arm :z (- z) :time 1000)
          (unix:sleep 1)
          (when (check-if-grabbed arm (car pat) nil)
            (throw 'loop last-z))
          (setq last-z z)))
      (pushback last-z ret-zs)
      (ros::ros-info "~A ~A ~A ~A safe z is ~A" arm bin (car pat) (cdr pat) last-z)
      (send *ri* :stop-grasp arm)
      ) ;; dolist
    ret-zs))

;; (check-pick-offset :rarm '(:c :f :i :l) '((:middle . 30)))
;; (check-pick-offset :larm '(:a :d :g :j) '((:middle . 30)))
(defun check-pick-offset (arm &optional (bins '(:c :f :i :l)) (pattern '((:middle . 30) (:middle . 80) (:middle . 150))))
  (let ((limit-map (make-hash-table)))
    (dolist (bin bins)
      (send *baxter* :fold-to-keep-object arm)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 3000)
      (send *ri* :wait-interpolation)
      (move-to-target-bin arm bin)
      (insert-to-pick-object-avs arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      ;; check
      (setf (gethash bin limit-map) (check-pick-offset-impl arm bin :pattern pattern))
      (insert-to-pick-object-avs arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      (avoid-shelf-pose-for-bin arm bin)
      (send *irtviewer* :draw-objects)
      (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
      (send *ri* :wait-interpolation)
      (move-to-target-bin arm bin)
      )
    (ros::ros-info "done")
    (format t "(case bin")
    (dolist (bin bins)
      (format t " (~A ~A)" bin (gethash bin limit-map)))
    (format t ")~%")))

(defun check-single-motion-of-pick-object (arm bin &key (pattern :middle) (depth 30))
  ;; move into shelf
  (insert-to-pick-object-avs arm bin)
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
  (send *ri* :wait-interpolation)
  (try-to-pick-object arm bin pattern depth :debug-mode t)
  (insert-to-pick-object-avs arm bin)
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *baxter* :angle-vector) 1000)
  (send *ri* :wait-interpolation)
  )

(defun check-all-motion-of-pick-object (arm bin)
  (let ((patterns '((:middle . 30) (:middle . 80) (:middle . 150) (:right-most . 80) (:left-most . 80)
                    (:rotate-and-left . 30) (:rotate-and-right . 30))))
    (move-to-target-bin arm bin)
    (dolist (pattern patterns)
      (check-single-motion-of-pick-object arm bin :pattern (car pattern) :depth (cdr pattern))
      )
    )
  )


(apc-init)
(warn "~% Commands ~%")
(warn "(check-pick) : Check all pick motion~%")
(warn "(check-pick-offset) : Check all offset~%")
(warn "(check-pick-object-offset-from-wall)~%")
(warn "(check-all-motion-of-pick-object) Check motion of pick-object~%")
